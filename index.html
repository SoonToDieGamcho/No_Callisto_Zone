<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Precision Tug-of-War (Instant BG)</title>
    <style>
        /* 폰트 정의 */
        @font-face {
            font-family: 'Escoredream';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_six@1.2/S-CoreDream-5Medium.woff') format('woff');
            font-weight: 500;
            font-display: swap;
        }

        body {
            font-family: 'Escoredream', sans-serif;
            background-color: #222;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            user-select: none;
            transition: background-color 0.1s;
            overflow: hidden;
            position: relative; 
        }

        /* [수정] 배경 오버레이 (transition 제거 -> 즉시 변경) */
        #bg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; 
            opacity: 0.15; 
            /* transition 속성 제거됨: 색상이 단번에 바뀜 */
            pointer-events: none;
        }

        /* 배경 상태 클래스 */
        .bg-normal { background-color: transparent; }
        .bg-good { background-color: #ffeb3b; }   /* 노랑 */
        .bg-perfect { background-color: #4caf50; } /* 초록 */
        .bg-bonus { background-color: #00e5ff; }   /* 하늘 */

        /* 플래시 효과 */
        .flash-effect { animation: flash-bg 0.3s ease-out; }
        @keyframes flash-bg {
            0% { background-color: #fff; }
            50% { background-color: #555; }
            100% { background-color: #222; }
        }

        .flash-fail { animation: flash-fail-bg 0.5s ease-out; }
        @keyframes flash-fail-bg {
            0% { background-color: #ff0000; }
            100% { background-color: #222; }
        }

        #game-container {
            width: 800px;
            padding: 20px;
            background: #333;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            position: relative;
            z-index: 10; 
        }

        #status-sidebar {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 15px;
            width: 200px;
            text-align: left;
            border: 1px solid #555;
            backdrop-filter: blur(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 10;
        }

        #status-sidebar h3 {
            margin: 0 0 15px 0;
            color: #ffd700;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            font-size: 18px;
        }

        .stat-row {
            margin-bottom: 12px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }

        .stat-label { color: #ccc; }
        .stat-val { font-weight: bold; color: #fff; }

        #stage-info {
            font-size: 24px;
            margin-bottom: 20px;
            color: #ffd700;
            font-weight: bold;
        }

        .field-track {
            position: relative;
            width: 100%;
            height: 60px;
            background: #444;
            border-radius: 30px;
            margin-bottom: 40px;
            overflow: hidden;
            border: 2px solid #555;
        }

        .zone-label {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-weight: bold;
            font-size: 20px;
            z-index: 2;
        }
        #label-c { left: 20px; color: #4caf50; }
        #label-b { right: 20px; color: #f44336; }

        #player-a {
            position: absolute;
            top: 5px;
            left: 50%;
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 15px white;
            z-index: 10;
            transition: transform 0.1s linear;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #222;
            font-weight: bold;
        }

        .gauge-container {
            position: relative;
            width: 60%;
            height: 40px;
            background: #111;
            border-radius: 5px;
            margin: 0 auto 20px auto;
            border: 2px solid #666;
            overflow: hidden;
        }

        #gauge-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #2196f3, #00bcd4);
            transition: width 0.05s linear;
        }

        #target-line {
            position: absolute;
            top: 0;
            left: 50%;
            width: 4px;
            height: 100%;
            background: #ffeb3b;
            box-shadow: 0 0 10px #ffeb3b;
            z-index: 5;
        }

        #action-btn {
            padding: 15px 40px;
            font-size: 20px;
            background: #ff5722;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 0 #bf360c;
            font-family: 'Escoredream', sans-serif;
        }
        #action-btn:active {
            box-shadow: 0 2px 0 #bf360c;
            transform: translateY(3px);
        }

        .guide-text {
            margin-top: 15px;
            font-size: 14px;
            color: #aaa;
        }

        #accuracy-text {
            height: 24px;
            margin-bottom: 10px;
            font-weight: bold;
            color: #aaa;
            font-size: 18px;
        }

        #floating-text-container {
            position: absolute;
            top: -150px; 
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            pointer-events: none; 
            z-index: 20;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }

        .hit-text {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            opacity: 0;
            animation: floatUpFade 2.5s ease-out forwards;
            text-shadow: 1px 1px 2px black;
        }

        .game-over-title {
            font-size: 50px;
            font-weight: 900;
            color: #ff3333;
            text-shadow: 3px 3px 0 #fff, 0 0 20px #ff0000;
            margin-bottom: 10px;
        }

        .game-over-sub {
            font-size: 24px;
            color: #fff;
            text-shadow: 1px 1px 5px black;
            margin-bottom: 15px;
        }

        .game-over-hint {
            font-size: 16px;
            color: #ffd700;
            animation: blink 1.5s infinite;
        }

        @keyframes floatUpFade {
            0% { opacity: 0; transform: translateY(20px); }
            10% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(-30px); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .stat-bad { color: #ff5252; }   
        .stat-good { color: #4caf50; }  
    </style>
</head>
<body>

<div id="bg-overlay"></div>

<div id="status-sidebar">
    <h3>현재 상태 (x1.0 기준)</h3>
    <div class="stat-row">
        <span class="stat-label">게이지 감소량</span>
        <span class="stat-val" id="disp-decay">1.00x</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">방해하는 힘</span>
        <span class="stat-val" id="disp-enemy">1.00x</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">판정선 속도</span>
        <span class="stat-val" id="disp-target">1.00x</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">클릭 파워</span>
        <span class="stat-val" id="disp-click">1.00x</span>
    </div>
</div>

<div id="game-container">
    <div id="floating-text-container"></div> 

    <div id="stage-info">STAGE 1</div>
    <div id="accuracy-text">Ready...</div>

    <div class="field-track">
        <div id="label-c" class="zone-label">목표 (C)</div>
        <div id="player-a">A</div>
        <div id="label-b" class="zone-label">추락 (B)</div>
    </div>

    <div class="gauge-container">
        <div id="gauge-fill"></div>
        <div id="target-line"></div>
    </div>

    <button id="action-btn">MASH! (스페이스바)</button>
    <div class="guide-text">보정 시간 0.05초 적용!</div>
</div>

<script>
    const CONFIG = {
        baseDecay: 1.0,         
        decayGrowth: 0.12,      
        baseClick: 16,          
        clickGrowth: 0.5,       
        
        baseEnemySpeed: 0.06,   
        pullPower: 0.5,         
        perfectPullSpeed: 0.6,  
        targetMoveSpeed: 0.2,   
        targetMoveGrowth: 0.1,  
        
        tolerance: 8.5,         
        minActiveGauge: 10,
        
        sustainThreshold: 0.5, 
        sustainBaseMult: 1.3,  
        sustainIncMult: 0.03,  
        sustainInterval: 0.1,
        
        gracePeriod: 0.05 
    };

    let state = {
        stage: 1,
        posA: 50,
        gauge: 0,
        targetPos: 60,
        targetDest: 60,
        isPlaying: false,
        animationId: null,
        
        lastTime: 0,
        perfectDuration: 0,
        graceTimer: 0 
    };

    const elBody = document.body;
    const elBgOverlay = document.getElementById('bg-overlay');
    const elPlayerA = document.getElementById('player-a');
    const elGaugeFill = document.getElementById('gauge-fill');
    const elTargetLine = document.getElementById('target-line');
    const elStageInfo = document.getElementById('stage-info');
    const elAccuracyText = document.getElementById('accuracy-text');
    const btnAction = document.getElementById('action-btn');
    const elFloatingContainer = document.getElementById('floating-text-container');
    
    const elDispDecay = document.getElementById('disp-decay');
    const elDispEnemy = document.getElementById('disp-enemy');
    const elDispTarget = document.getElementById('disp-target');
    const elDispClick = document.getElementById('disp-click');

    function getStageStats(stageLevel) {
        return {
            decay: CONFIG.baseDecay + ((stageLevel - 1) * CONFIG.decayGrowth),
            click: CONFIG.baseClick + ((stageLevel - 1) * CONFIG.clickGrowth),
            enemySpeed: CONFIG.baseEnemySpeed + ((stageLevel - 1) * 0.02),
            targetSpeed: CONFIG.targetMoveSpeed + ((stageLevel - 1) * CONFIG.targetMoveGrowth)
        };
    }

    function updateSidebar() {
        const stats = getStageStats(state.stage);
        
        const rateDecay = (stats.decay / CONFIG.baseDecay).toFixed(2);
        const rateEnemy = (stats.enemySpeed / CONFIG.baseEnemySpeed).toFixed(2);
        const rateTarget = (stats.targetSpeed / CONFIG.targetMoveSpeed).toFixed(2);
        const rateClick = (stats.click / CONFIG.baseClick).toFixed(2);

        elDispDecay.innerText = `${rateDecay}x`;
        elDispEnemy.innerText = `${rateEnemy}x`;
        elDispTarget.innerText = `${rateTarget}x`;
        elDispClick.innerText = `${rateClick}x`;
    }

    function gameLoop(timestamp) {
        if (!state.isPlaying) return;

        const dt = (timestamp - state.lastTime) / 1000;
        state.lastTime = timestamp;

        const stats = getStageStats(state.stage);

        // 1. 게이지 감소
        if (state.gauge > 0) {
            state.gauge -= stats.decay; 
            if (state.gauge < 0) state.gauge = 0;
        }

        // 2. 판정선 이동
        if (Math.abs(state.targetPos - state.targetDest) < 2) {
            state.targetDest = Math.random() * 80 + 15; 
        }
        const direction = state.targetDest > state.targetPos ? 1 : -1;
        state.targetPos += direction * stats.targetSpeed;

        // 3. 물리적 판정
        let diff = Math.abs(state.gauge - state.targetPos);
        let rawEfficiency = 0;
        let rawJudgment = "MISS";

        if (state.gauge < CONFIG.minActiveGauge) {
            rawJudgment = "LOW";
            rawEfficiency = 0;
        } else {
            if (diff < CONFIG.tolerance) {
                rawJudgment = "PERFECT";
                rawEfficiency = 1;
            } else if (diff < 35) {
                rawJudgment = "GOOD";
                rawEfficiency = 1 - ((diff - CONFIG.tolerance) / (35 - CONFIG.tolerance));
            } else {
                rawJudgment = "MISS";
                rawEfficiency = 0;
            }
        }

        // 4. 보정 로직
        let finalJudgment = rawJudgment;
        let finalEfficiency = rawEfficiency;

        if (rawJudgment === "PERFECT") {
            state.graceTimer = CONFIG.gracePeriod;
        } else {
            if (state.graceTimer > 0) {
                state.graceTimer -= dt;
                finalJudgment = "PERFECT";
                finalEfficiency = 1;
            }
        }

        // 5. 판정 처리 및 배경색
        let displayText = "";
        let displayColor = "#aaa";
        let moveAmount = 0;
        let bgClass = "bg-normal";

        if (finalJudgment === "LOW") {
            displayText = "게이지 부족!";
            displayColor = "#888";
            const playerForce = CONFIG.pullPower * 0;
            moveAmount = stats.enemySpeed - playerForce;
            state.perfectDuration = 0;

        } else if (finalJudgment === "PERFECT") {
            state.perfectDuration += dt;
            let currentPullSpeed = CONFIG.perfectPullSpeed;

            if (state.perfectDuration >= CONFIG.sustainThreshold) {
                const extraTime = state.perfectDuration - CONFIG.sustainThreshold;
                const extraSteps = Math.floor(extraTime / CONFIG.sustainInterval);
                const multiplier = CONFIG.sustainBaseMult + (extraSteps * CONFIG.sustainIncMult);
                
                currentPullSpeed *= multiplier;

                displayText = `PERFECT x${multiplier.toFixed(2)}`;
                displayColor = "#00e5ff"; 
                bgClass = "bg-bonus";
            } else {
                displayText = "PERFECT!";
                displayColor = "#4caf50";
                bgClass = "bg-perfect";
            }

            moveAmount = -currentPullSpeed;

        } else if (finalJudgment === "GOOD") {
            state.perfectDuration = 0;
            displayText = "GOOD";
            displayColor = "#ffeb3b";
            bgClass = "bg-good";
            
            const playerForce = CONFIG.pullPower * finalEfficiency;
            moveAmount = stats.enemySpeed - playerForce;

        } else { // MISS
            state.perfectDuration = 0;
            displayText = "MISS";
            displayColor = "#f44336";
            
            const playerForce = 0;
            moveAmount = stats.enemySpeed - playerForce;
        }

        elBgOverlay.className = bgClass;

        elAccuracyText.innerText = displayText;
        elAccuracyText.style.color = displayColor;
        
        state.posA += moveAmount;

        // 6. 결과 확인
        if (state.posA <= 0) {
            winStage();
        } else if (state.posA >= 100) {
            gameOver();
        } else {
            render();
            state.animationId = requestAnimationFrame(gameLoop);
        }
    }

    function render() {
        let visualPos = state.posA;
        if(visualPos < 0) visualPos = 0;
        if(visualPos > 100) visualPos = 100;

        elPlayerA.style.left = `calc(${visualPos}% - 25px)`; 
        elGaugeFill.style.width = `${state.gauge}%`;
        elTargetLine.style.left = `${state.targetPos}%`;
    }

    function increaseGauge() {
        if (!state.isPlaying) return;
        
        const stats = getStageStats(state.stage);
        state.gauge += stats.click;
        if (state.gauge > 100) state.gauge = 100;
        
        elGaugeFill.style.filter = "brightness(1.3)";
        setTimeout(() => elGaugeFill.style.filter = "brightness(1)", 50);
    }

    function startGame() {
        state.isPlaying = true;
        state.posA = 50;
        state.gauge = 0;
        state.targetPos = 50;
        state.targetDest = 60;
        state.stage = 1; 
        state.lastTime = performance.now(); 
        state.perfectDuration = 0; 
        state.graceTimer = 0;

        elFloatingContainer.innerHTML = ''; 
        updateSidebar();
        elStageInfo.innerText = `STAGE 1`;
        
        elAccuracyText.innerText = "준비...";
        btnAction.innerText = "연타! (스페이스바)";
        
        elBody.classList.remove('flash-fail');
        elBody.classList.remove('flash-effect');
        elBgOverlay.className = "bg-normal";

        state.animationId = requestAnimationFrame(gameLoop);
    }

    function showFloatingText(prevStats, currStats) {
        elFloatingContainer.innerHTML = ''; 

        const decayRate = (currStats.decay / prevStats.decay).toFixed(2);
        createHitElement(`게이지 감소량: x${decayRate}`, "stat-bad");

        const enemyRate = (currStats.enemySpeed / prevStats.enemySpeed).toFixed(2);
        createHitElement(`방해하는 힘: x${enemyRate}`, "stat-bad");
        
        const targetRate = (currStats.targetSpeed / prevStats.targetSpeed).toFixed(2);
        createHitElement(`판정선 속도: x${targetRate}`, "stat-bad");

        const clickRate = (currStats.click / prevStats.click).toFixed(2);
        createHitElement(`클릭 파워: x${clickRate}`, "stat-good");
    }

    function createHitElement(text, className) {
        const div = document.createElement('div');
        div.className = `hit-text ${className}`;
        div.innerText = text;
        elFloatingContainer.appendChild(div);
    }

    function winStage() {
        cancelAnimationFrame(state.animationId);

        const prevStats = getStageStats(state.stage);
        state.stage++;
        const currStats = getStageStats(state.stage);

        showFloatingText(prevStats, currStats);
        updateSidebar(); 

        elStageInfo.innerText = `STAGE ${state.stage}`;

        elBody.classList.remove('flash-fail');
        elBody.classList.remove('flash-effect');
        void elBody.offsetWidth;
        elBody.classList.add('flash-effect');
        elBgOverlay.className = "bg-normal";

        state.posA = 50; 
        state.gauge = 0;
        state.perfectDuration = 0;
        state.graceTimer = 0;
        state.lastTime = performance.now();

        render();
        state.animationId = requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        state.isPlaying = false;
        cancelAnimationFrame(state.animationId);

        elFloatingContainer.innerHTML = '';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'game-over-title';
        titleDiv.innerText = 'GAME OVER';
        
        const subDiv = document.createElement('div');
        subDiv.className = 'game-over-sub';
        subDiv.innerText = `기록: STAGE ${state.stage}`;

        const hintDiv = document.createElement('div');
        hintDiv.className = 'game-over-hint';
        hintDiv.innerText = '다시 시작하려면 버튼을 누르세요';

        elFloatingContainer.appendChild(titleDiv);
        elFloatingContainer.appendChild(subDiv);
        elFloatingContainer.appendChild(hintDiv);
        
        elBody.classList.remove('flash-effect');
        elBody.classList.remove('flash-fail');
        void elBody.offsetWidth;
        elBody.classList.add('flash-fail');
        
        btnAction.innerText = "재시작 (스페이스바)";
    }

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            if (!state.isPlaying && !e.repeat) startGame(); 
            else increaseGauge();
        }
    });

    btnAction.addEventListener('mousedown', () => {
        if (!state.isPlaying) startGame();
        else increaseGauge();
    });

    updateSidebar();
    render();
    
</script>

</body>
</html>