<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fan Game Prototype</title>
    <style>
        /* 폰트 정의 */
        @font-face {
            font-family: 'Escoredream';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_six@1.2/S-CoreDream-5Medium.woff') format('woff');
            font-weight: 500;
            font-display: swap;
        }

        body {
            font-family: 'Escoredream', sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            /* 2. 전체 뒷배경 이미지 */
            background: url('images/bg.png') no-repeat center center;
            background-size: cover;
            /* 7. 모바일 더블탭 확대 방지 */
            touch-action: manipulation; 
        }

        /* 1. 게임 박스 (메인 컨테이너) */
        #game-container {
            width: 800px;
            height: 500px; /* 박스 이미지 비율에 맞춰 조정 필요 */
            position: relative;
            /* 이미지로 대체 */
            background: url('images/box.png') no-repeat center center;
            background-size: 100% 100%; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            justify-content: center; /* 내부 요소 수직 중앙 정렬 */
            align-items: center;
        }

        /* 6. 배경 색상 오버레이 (박스 내부 틴트용) */
        #color-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 15px; /* 박스 모서리에 맞춤 */
            pointer-events: none;
            z-index: 1; /* 배경(0) 위, 트랙(2) 아래 */
            transition: background-color 0.1s, opacity 0.1s;
        }

        /* 스테이지 정보 (상단 중앙) */
        #stage-info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 28px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
            z-index: 10;
        }

        /* 3. 경로 (트랙) - 반투명 */
        .field-track {
            position: relative;
            width: 90%;
            height: 80px;
            /* 반투명 검정으로 뒤쪽 box.png가 은은하게 비침 */
            background: rgba(0, 0, 0, 0.3); 
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 40px;
            margin-bottom: 30px; /* 게이지바와의 간격 */
            overflow: visible; /* 이미지가 튀어나와도 보이게 */
            z-index: 5; /* 오버레이 위 */
        }

        /* 4. 캐릭터 및 지점 이미지화 */
        .obj-image {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 20; /* 최상단 */
        }

        /* C (Goal) */
        #img-c {
            left: -20px; /* 트랙 밖으로 살짝 뺌 */
            width: 100px; 
            height: auto;
        }

        /* 8. C 배경 이펙트 */
        #effect-c {
            position: absolute;
            left: -50px; /* C 뒤쪽 */
            top: 50%;
            transform: translateY(-50%);
            width: 160px;
            height: 160px;
            background: url('images/ef.png') no-repeat center center;
            background-size: contain;
            z-index: 15; /* C(20)보다 아래, 트랙(5)보다 위 */
            opacity: 0.2; /* 초기값 */
            transition: opacity 0.1s;
            pointer-events: none;
        }

        /* B (Start/Death) */
        #img-b {
            right: -20px;
            width: 80px;
            height: auto;
        }

        /* A (Player) - 움직임 */
        #player-a {
            /* left값은 JS로 제어 */
            width: 70px; 
            height: auto;
            top: 50%;
            transform: translate(-50%, -50%); /* 중심점 기준 이동 */
            z-index: 30; /* 제일 위 */
            transition: left 0.1s linear;
        }

        /* 게이지바 컨테이너 */
        .gauge-container {
            position: relative;
            width: 70%;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
            z-index: 10;
        }

        #gauge-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #3DFFEA, #63F2FF);
            box-shadow: 0 0 10px #3DFFEA;
            transition: width 0.05s linear;
        }

        #target-line {
            position: absolute;
            top: 0;
            left: 50%;
            width: 4px;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 8px #fff;
            z-index: 5;
        }

        /* 5. 스탯 표시 (좌측 하단 구석) */
        #stats-corner {
            position: absolute;
            bottom: 15px;
            left: 20px;
            text-align: left;
            z-index: 10;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.4;
            /* 검은 박스 제거됨 */
        }
        
        .stat-val { color: #fff; font-weight: bold; }

        /* 판정 텍스트 (게이지바 위) */
        #accuracy-text {
            height: 24px;
            margin-bottom: 5px;
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #3DFFEA;
            z-index: 10;
        }

        /* 히트 텍스트 등 UI */
        #floating-text-container {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 50;
        }
        
        .hit-text {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #3DFFEA;
            animation: floatUp 1s forwards;
        }
        
        @keyframes floatUp {
            to { opacity: 0; transform: translateY(-30px); }
        }

        /* 전체 클릭 영역 (버튼 대체) */
        #click-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            cursor: pointer;
            /* 모바일 탭 하이라이트 제거 */
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body>

<div id="click-layer"></div> <div id="game-container">
    <div id="color-overlay"></div>

    <div id="stage-info">STAGE 1</div>
    <div id="floating-text-container"></div>
    
    <div id="stats-corner">
        <div>감소: <span id="disp-decay" class="stat-val">1.0x</span></div>
        <div>방해: <span id="disp-enemy" class="stat-val">1.0x</span></div>
        <div>판정: <span id="disp-target" class="stat-val">1.0x</span></div>
        <div>파워: <span id="disp-click" class="stat-val">1.0x</span></div>
    </div>

    <div id="accuracy-text">READY</div>

    <div class="field-track">
        <div id="effect-c"></div>
        <img src="images/C.png" id="img-c" class="obj-image" alt="C">
        <img src="images/A.png" id="player-a" class="obj-image" alt="A">
        <img src="images/B.png" id="img-b" class="obj-image" alt="B">
    </div>

    <div class="gauge-container">
        <div id="gauge-fill"></div>
        <div id="target-line"></div>
    </div>
</div>

<script>
    const CONFIG = {
        baseDecay: 1.0,         
        decayGrowth: 0.12,      
        baseClick: 16,          
        clickGrowth: 0.5,       
        
        baseEnemySpeed: 0.06,   
        pullPower: 0.5,         
        perfectPullSpeed: 0.6,  
        targetMoveSpeed: 0.2,   
        targetMoveGrowth: 0.1,  
        
        tolerance: 8.5,         
        minActiveGauge: 10,
        
        sustainThreshold: 0.5, 
        sustainBaseMult: 1.3,  
        sustainIncMult: 0.03,  
        sustainInterval: 0.1,
        
        gracePeriod: 0.05 
    };

    let state = {
        stage: 1,
        posA: 50,
        gauge: 0,
        targetPos: 60,
        targetDest: 60,
        isPlaying: false,
        lastTime: 0,
        perfectDuration: 0,
        graceTimer: 0 
    };

    // DOM Elements
    const elOverlay = document.getElementById('color-overlay');
    const elPlayerA = document.getElementById('player-a');
    const elGaugeFill = document.getElementById('gauge-fill');
    const elTargetLine = document.getElementById('target-line');
    const elStageInfo = document.getElementById('stage-info');
    const elAccuracyText = document.getElementById('accuracy-text');
    const elEffectC = document.getElementById('effect-c');
    const elFloatingContainer = document.getElementById('floating-text-container');
    const elClickLayer = document.getElementById('click-layer');
    
    // Stats Elements
    const elDispDecay = document.getElementById('disp-decay');
    const elDispEnemy = document.getElementById('disp-enemy');
    const elDispTarget = document.getElementById('disp-target');
    const elDispClick = document.getElementById('disp-click');

    function getStageStats(stageLevel) {
        return {
            decay: CONFIG.baseDecay + ((stageLevel - 1) * CONFIG.decayGrowth),
            click: CONFIG.baseClick + ((stageLevel - 1) * CONFIG.clickGrowth),
            enemySpeed: CONFIG.baseEnemySpeed + ((stageLevel - 1) * 0.02),
            targetSpeed: CONFIG.targetMoveSpeed + ((stageLevel - 1) * CONFIG.targetMoveGrowth)
        };
    }

    function updateStatsUI() {
        const stats = getStageStats(state.stage);
        elDispDecay.innerText = (stats.decay / CONFIG.baseDecay).toFixed(2) + 'x';
        elDispEnemy.innerText = (stats.enemySpeed / CONFIG.baseEnemySpeed).toFixed(2) + 'x';
        elDispTarget.innerText = (stats.targetSpeed / CONFIG.targetMoveSpeed).toFixed(2) + 'x';
        elDispClick.innerText = (stats.click / CONFIG.baseClick).toFixed(2) + 'x';
    }

    function gameLoop(timestamp) {
        if (!state.isPlaying) return;

        const dt = (timestamp - state.lastTime) / 1000;
        state.lastTime = timestamp;

        const stats = getStageStats(state.stage);

        // 1. 게이지 감소
        if (state.gauge > 0) {
            state.gauge -= stats.decay;
            if (state.gauge < 0) state.gauge = 0;
        }

        // 2. 판정선 이동
        if (Math.abs(state.targetPos - state.targetDest) < 2) {
            state.targetDest = Math.random() * 80 + 15; 
        }
        const direction = state.targetDest > state.targetPos ? 1 : -1;
        state.targetPos += direction * stats.targetSpeed;

        // 3. 판정 계산
        let diff = Math.abs(state.gauge - state.targetPos);
        let rawEfficiency = 0;
        let rawJudgment = "MISS";

        if (state.gauge < CONFIG.minActiveGauge) {
            rawJudgment = "LOW";
        } else {
            if (diff < CONFIG.tolerance) {
                rawJudgment = "PERFECT";
                rawEfficiency = 1;
            } else if (diff < 35) {
                rawJudgment = "GOOD";
                rawEfficiency = 1 - ((diff - CONFIG.tolerance) / (35 - CONFIG.tolerance));
            } else {
                rawJudgment = "MISS";
                rawEfficiency = 0;
            }
        }

        // 4. 보정 (Grace Period)
        let finalJudgment = rawJudgment;
        if (rawJudgment === "PERFECT") {
            state.graceTimer = CONFIG.gracePeriod;
        } else if (state.graceTimer > 0) {
            state.graceTimer -= dt;
            finalJudgment = "PERFECT";
            rawEfficiency = 1; // 보정 시 효율 100%
        }

        // 5. 로직 및 렌더링 값 설정
        let displayText = "";
        let moveAmount = 0;
        let overlayColor = "transparent";
        let overlayAlpha = 0;
        let effectAlpha = 0.2; // 기본 20%

        if (finalJudgment === "LOW") {
            displayText = "LOW";
            const playerForce = 0;
            moveAmount = stats.enemySpeed - playerForce;
            state.perfectDuration = 0;
            
            // 색상 없음
            overlayAlpha = 0;

        } else if (finalJudgment === "PERFECT") {
            state.perfectDuration += dt;
            let currentPullSpeed = CONFIG.perfectPullSpeed;

            // 보너스
            if (state.perfectDuration >= CONFIG.sustainThreshold) {
                // [보너스 모드] #63F2FF, 진하게
                const extraTime = state.perfectDuration - CONFIG.sustainThreshold;
                const extraSteps = Math.floor(extraTime / CONFIG.sustainInterval);
                const multiplier = CONFIG.sustainBaseMult + (extraSteps * CONFIG.sustainIncMult);
                currentPullSpeed *= multiplier;

                displayText = `MAX x${multiplier.toFixed(2)}`;
                
                // 보너스 색상 (진한 하늘색)
                overlayColor = "#63F2FF";
                overlayAlpha = 0.6; // 매우 진함
                effectAlpha = 0.9; // 이펙트 거의 불투명
            } else {
                // [일반 퍼펙트] #3DFFEA
                displayText = "PERFECT";
                overlayColor = "#3DFFEA";
                overlayAlpha = 0.4; // 중간 진함
                effectAlpha = 0.7; // 이펙트 70%
            }
            moveAmount = -currentPullSpeed;

        } else if (finalJudgment === "GOOD") {
            state.perfectDuration = 0;
            displayText = "GOOD";
            const playerForce = CONFIG.pullPower * rawEfficiency;
            moveAmount = stats.enemySpeed - playerForce;
            
            // [Good] #3DFFEA, 연하게
            overlayColor = "#3DFFEA";
            overlayAlpha = 0.2; 
            // 효율에 따라 이펙트 20%~70% 보간
            effectAlpha = 0.2 + (rawEfficiency * 0.5);

        } else { // MISS
            state.perfectDuration = 0;
            displayText = "MISS";
            moveAmount = stats.enemySpeed;
            
            // [Miss] #3DFFEA, 아주 연하게
            overlayColor = "#3DFFEA";
            overlayAlpha = 0.05; 
            effectAlpha = 0.2;
        }

        // 6. UI 및 DOM 업데이트
        elAccuracyText.innerText = displayText;
        
        // 6-1. 색상 오버레이 업데이트
        if(overlayAlpha > 0) {
            // hex -> rgba 변환 (간단히 opacity로 처리)
            elOverlay.style.backgroundColor = overlayColor;
            elOverlay.style.opacity = overlayAlpha;
        } else {
            elOverlay.style.opacity = 0;
        }

        // 8. C 이펙트 알파값 업데이트
        elEffectC.style.opacity = effectAlpha;

        state.posA += moveAmount;

        // 결과 처리
        if (state.posA <= 0) winStage();
        else if (state.posA >= 100) gameOver();
        else {
            render();
            state.animationId = requestAnimationFrame(gameLoop);
        }
    }

    function render() {
        let visualPos = state.posA;
        if(visualPos < 0) visualPos = 0;
        if(visualPos > 100) visualPos = 100;

        // A 이미지 이동
        elPlayerA.style.left = `${visualPos}%`;
        
        // 게이지 바
        elGaugeFill.style.width = `${state.gauge}%`;
        elTargetLine.style.left = `${state.targetPos}%`;
    }

    function increaseGauge() {
        if (!state.isPlaying) return;
        
        const stats = getStageStats(state.stage);
        state.gauge += stats.click;
        if (state.gauge > 100) state.gauge = 100;
        
        // 게이지 찰 때 잠깐 밝게
        elGaugeFill.style.filter = "brightness(1.5)";
        setTimeout(() => elGaugeFill.style.filter = "brightness(1)", 50);
    }

    function startGame() {
        state.isPlaying = true;
        state.posA = 50;
        state.gauge = 0;
        state.stage = 1; 
        state.targetPos = 50;
        state.targetDest = 60;
        state.lastTime = performance.now(); 
        state.perfectDuration = 0; 
        state.graceTimer = 0;

        elStageInfo.innerText = "STAGE 1";
        elFloatingContainer.innerHTML = ''; 
        elAccuracyText.innerText = "START";
        updateStatsUI();

        state.animationId = requestAnimationFrame(gameLoop);
    }

    function winStage() {
        cancelAnimationFrame(state.animationId);
        state.stage++;
        
        // 히트 텍스트 (다음 스테이지)
        const div = document.createElement('div');
        div.className = 'hit-text';
        div.innerText = `STAGE ${state.stage}`;
        elFloatingContainer.appendChild(div);
        setTimeout(()=> div.remove(), 1000);

        elStageInfo.innerText = `STAGE ${state.stage}`;
        updateStatsUI();
        
        // 리셋
        state.posA = 50; 
        state.gauge = 0;
        state.perfectDuration = 0;
        state.lastTime = performance.now();

        state.animationId = requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        state.isPlaying = false;
        cancelAnimationFrame(state.animationId);

        elFloatingContainer.innerHTML = '';
        elAccuracyText.innerText = "GAME OVER";
        
        // 간단한 재시작 안내
        const div = document.createElement('div');
        div.className = 'hit-text';
        div.innerText = "TAP TO RESTART";
        div.style.color = "#ff3333";
        elFloatingContainer.appendChild(div);
    }

    // 입력 핸들러 (연타)
    // 7. 모바일 더블탭 문제 해결 -> clickLayer에 이벤트 위임
    elClickLayer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        handleInput();
    });
    elClickLayer.addEventListener('touchstart', (e) => {
        e.preventDefault(); // 더블탭 확대 방지 핵심
        handleInput();
    });

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            handleInput();
        }
    });

    function handleInput() {
        if (!state.isPlaying) {
            startGame();
        } else {
            increaseGauge();
        }
    }

    // 초기화
    updateStatsUI();
    render();

</script>
</body>
</html>
