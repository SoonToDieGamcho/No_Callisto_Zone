<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NoCallisto</title>
    <link rel="icon" href="images/fav.png" type="image/png">
    
    <style>
        @font-face {
            font-family: 'Escoredream';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_six@1.2/S-CoreDream-5Medium.woff') format('woff');
            font-weight: 500;
            font-display: swap;
        }

        body {
            font-family: 'Escoredream', sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            background: url('images/bg.png') no-repeat center center;
            background-size: cover;
            touch-action: manipulation; 
        }

        /* 인트로 모달 */
        #intro-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .intro-content {
            background: #444;
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: left;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 2px solid #666;
            line-height: 1.6;
        }

        .intro-content p { margin-bottom: 20px; font-size: 18px; }
        .highlight-blue { color: #3DFFEA; font-weight: bold; }
        .highlight-perfect { text-shadow: 0 0 10px #4caf50; font-weight: bold; color: #fff; }
        .highlight-max { text-shadow: 0 0 15px #3DFFEA, 0 0 30px #3DFFEA; font-weight: bold; color: #fff; }

        #intro-close-btn {
            padding: 15px 40px;
            font-size: 20px;
            background: #3DFFEA;
            border: none;
            color: #222;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 0 #00bfa5;
            font-family: 'Escoredream', sans-serif;
            display: block;
            margin: 30px auto 0 auto;
        }

        /* 플래시 레이어 */
        #flash-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 900; 
            opacity: 0;
        }

        .flash-white { animation: flash-w 0.6s ease-out; }
        @keyframes flash-w { 0% { background-color: white; opacity: 0.8; } 100% { background-color: white; opacity: 0; } }

        .flash-red { animation: flash-r 0.6s ease-out; }
        @keyframes flash-r { 0% { background-color: red; opacity: 0.6; } 100% { background-color: red; opacity: 0; } }

        #bg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1; 
            border-radius: 15px; 
        }

        .bg-normal { background-color: transparent; }
        .bg-good { background-color: #3DFFEA; opacity: 0.2; }
        .bg-perfect { background-color: #3DFFEA; opacity: 0.4; }
        .bg-bonus { background-color: #63F2FF; opacity: 0.6; }
        .bg-miss { background-color: #3DFFEA; opacity: 0.05; }

        #game-container {
            width: 800px;
            height: 500px;
            position: relative;
            background: url('images/box.png') no-repeat center center;
            background-size: 100% 100%; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            justify-content: flex-start; 
            align-items: center;
            overflow: hidden; 
        }

        #stage-info {
            margin-top: 30px; 
            font-size: 28px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
            z-index: 10;
        }

        #floating-text-container {
            position: relative; 
            height: 80px; 
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            pointer-events: none;
        }
        
        .hit-text {
            font-size: 18px; 
            font-weight: bold;
            color: #3DFFEA; 
            text-shadow: 0 0 10px #3DFFEA;
            animation: floatUpFade 2.0s ease-out forwards;
        }

        @keyframes floatUpFade {
            0% { opacity: 0; transform: translateY(10px); }
            10% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(-10px); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* 판정 텍스트 (기록 표시 겸용) */
        #accuracy-text {
            height: 30px;
            font-size: 24px;
            font-weight: bold;
            color: #fff; 
            z-index: 10;
            margin-bottom: 20px; 
            white-space: nowrap; /* 줄바꿈 방지 */
        }

        .field-track {
            position: relative;
            width: 90%;
            height: 80px;
            background: rgba(0, 0, 0, 0.3); 
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 40px;
            margin-bottom: 25px; 
            overflow: visible; 
            z-index: 5; 
        }

        .obj-image {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 20;
        }

        #img-c { left: -20px; width: 100px; height: auto; }
        
        #effect-c {
            position: absolute;
            left: -50px;
            top: 50%;
            transform: translateY(-50%) scale(2.4);
            width: 160px;
            height: 160px;
            background: url('images/ef.png') no-repeat center center;
            background-size: contain;
            z-index: 15;
            opacity: 0.2;
            transition: opacity 0.1s;
            pointer-events: none;
        }

        #img-b { right: -39px; width: 80px; height: auto; }

        #player-a {
            width: 77px; 
            height: auto;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 30;
            transition: left 0.1s linear;
        }

        .gauge-container {
            position: relative;
            width: 70%;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
            z-index: 10;
            margin-bottom: 20px; 
        }

        #gauge-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #3DFFEA, #63F2FF);
            box-shadow: 0 0 10px #3DFFEA;
            transition: width 0.05s linear;
        }

        #target-line {
            position: absolute;
            top: 0;
            left: 50%;
            width: 4px;
            height: 100%;
            background: #000;
            border: 1px solid #fff;
            box-sizing: border-box;
            z-index: 5;
        }

        #stats-corner {
            position: absolute;
            bottom: 15px;
            left: 20px;
            text-align: left;
            z-index: 10;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }
        
        .stat-val { color: #fff; font-weight: bold; }
        .stat-diff {
            display: inline-block;
            margin-left: 5px;
            font-size: 11px;
            font-weight: bold;
            opacity: 0; 
            transition: opacity 1.5s ease-in; 
        }
        .diff-bad { color: #ff5252; }
        .diff-good { color: #4caf50; }

        #action-btn {
            padding: 15px 40px;
            font-size: 20px;
            background: rgba(61, 255, 234, 0.3);
            border: 2px solid #fff;
            color: #fff;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(61, 255, 234, 0.5);
            font-family: 'Escoredream', sans-serif;
            z-index: 50; 
            margin-top: 5px;
            transition: all 0.1s;
        }
        #action-btn:active {
            background: rgba(61, 255, 234, 0.6);
            box-shadow: 0 0 5px rgba(61, 255, 234, 0.8);
            transform: scale(0.95);
        }
        #action-btn.locked {
            background: rgba(100, 100, 100, 0.3);
            border-color: #888;
            color: #aaa;
            box-shadow: none;
            cursor: not-allowed;
        }

        .game-over-title {
            position: absolute; 
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            font-weight: 900;
            color: #ff3333;
            text-shadow: 3px 3px 0 #fff, 0 0 20px #ff0000;
            z-index: 100;
            width: 100%;
            text-align: center;
        }
    </style>
</head>
<body>

<div id="intro-modal">
    <div class="intro-content">
        <p><span class="highlight-blue">칼리스토</span>가 <span class="highlight-blue">호엔하임</span>에게 다가가는 것을 막아야 합니다!</p>
        <p><span class="highlight-blue">SPACE</span>를 연타하면 게이지가 오르며, 움직이는 판정선에 가깝게 게이지를 유지하면 칼리스토를 빛으로 유혹할 수 있습니다.</p>
        <p>판정선에 가깝게 <span class="highlight-perfect">PERFECT</span>를 유지하면 <span class="highlight-max">MAX</span>상태로 돌입해 더욱 빠르게 끌어들일 수 있습니다.</p>
        <p>스테이지가 올라갈수록 판정선은 더 빠르게 움직이고, <span class="highlight-blue">칼리스토</span>도 재빨라집니다.</p>
        <p><span class="highlight-blue">마튼</span>이 몇 명의 <span class="highlight-blue">호엔하임</span>을 구할 수 있을까요?</p>
        <button id="intro-close-btn">확인</button>
    </div>
</div>

<div id="flash-layer"></div>

<div id="game-container">
    <div id="bg-overlay"></div>
    <div id="stage-info">STAGE 1</div>
    <div id="floating-text-container"></div>
    
    <div id="stats-corner">
        <div>게이지 감소량: <span id="disp-decay" class="stat-val">1.0x</span> <span id="diff-decay" class="stat-diff diff-bad"></span></div>
        <div>칼리스토 속도: <span id="disp-enemy" class="stat-val">1.0x</span> <span id="diff-enemy" class="stat-diff diff-bad"></span></div>
        <div>판정선 속도: <span id="disp-target" class="stat-val">1.0x</span> <span id="diff-target" class="stat-diff diff-bad"></span></div>
        <div>클릭 파워: <span id="disp-click" class="stat-val">1.0x</span> <span id="diff-click" class="stat-diff diff-good"></span></div>
    </div>

    <div id="accuracy-text">READY</div>

    <div class="field-track">
        <div id="effect-c"></div>
        <img src="images/C.png" id="img-c" class="obj-image" alt="C">
        <img src="images/A.png" id="player-a" class="obj-image" alt="A">
        <img src="images/B.png" id="img-b" class="obj-image" alt="B">
    </div>

    <div class="gauge-container">
        <div id="gauge-fill"></div>
        <div id="target-line"></div>
    </div>

    <button id="action-btn">SPACE! (SPACE)</button>
</div>

<script>
    const CONFIG = {
        baseDecay: 1.0, decayGrowth: 0.12, baseClick: 16, clickGrowth: 0.5,
        baseEnemySpeed: 0.06, pullPower: 0.5, perfectPullSpeed: 0.6,
        targetMoveSpeed: 0.2, targetMoveGrowth: 0.1, tolerance: 8.5, minActiveGauge: 10,
        sustainThreshold: 0.5, sustainBaseMult: 1.3, sustainIncMult: 0.03, sustainInterval: 0.1,
        gracePeriod: 0.05 
    };

    let state = {
        stage: 1, posA: 50, gauge: 0, targetPos: 60, targetDest: 60,
        isPlaying: false, lastTime: 0, perfectDuration: 0, graceTimer: 0,
        isRestartLocked: false, isModalOpen: true 
    };

    // DOM References
    const elIntroModal = document.getElementById('intro-modal');
    const btnIntroClose = document.getElementById('intro-close-btn');
    const elFlashLayer = document.getElementById('flash-layer');
    const elBgOverlay = document.getElementById('bg-overlay');
    const elPlayerA = document.getElementById('player-a');
    const elGaugeFill = document.getElementById('gauge-fill');
    const elTargetLine = document.getElementById('target-line');
    const elStageInfo = document.getElementById('stage-info');
    const elAccuracyText = document.getElementById('accuracy-text');
    const btnAction = document.getElementById('action-btn');
    const elFloatingContainer = document.getElementById('floating-text-container');
    const elEffectC = document.getElementById('effect-c');
    
    // Stats
    const elDispDecay = document.getElementById('disp-decay'), elDiffDecay = document.getElementById('diff-decay');
    const elDispEnemy = document.getElementById('disp-enemy'), elDiffEnemy = document.getElementById('diff-enemy');
    const elDispTarget = document.getElementById('disp-target'), elDiffTarget = document.getElementById('diff-target');
    const elDispClick = document.getElementById('disp-click'), elDiffClick = document.getElementById('diff-click');

    btnIntroClose.addEventListener('click', () => {
        elIntroModal.style.display = 'none';
        state.isModalOpen = false;
    });

    function getStageStats(stageLevel) {
        return {
            decay: CONFIG.baseDecay + ((stageLevel - 1) * CONFIG.decayGrowth),
            click: CONFIG.baseClick + ((stageLevel - 1) * CONFIG.clickGrowth),
            enemySpeed: CONFIG.baseEnemySpeed + ((stageLevel - 1) * 0.02),
            targetSpeed: CONFIG.targetMoveSpeed + ((stageLevel - 1) * CONFIG.targetMoveGrowth)
        };
    }

    function updateStatsUI(prevStats = null) {
        const currStats = getStageStats(state.stage);
        elDispDecay.innerText = (currStats.decay / CONFIG.baseDecay).toFixed(2) + 'x';
        elDispEnemy.innerText = (currStats.enemySpeed / CONFIG.baseEnemySpeed).toFixed(2) + 'x';
        elDispTarget.innerText = (currStats.targetSpeed / CONFIG.targetMoveSpeed).toFixed(2) + 'x';
        elDispClick.innerText = (currStats.click / CONFIG.baseClick).toFixed(2) + 'x';

        if (prevStats) {
            showDiff(elDiffDecay, (currStats.decay - prevStats.decay) / CONFIG.baseDecay);
            showDiff(elDiffEnemy, (currStats.enemySpeed - prevStats.enemySpeed) / CONFIG.baseEnemySpeed);
            showDiff(elDiffTarget, (currStats.targetSpeed - prevStats.targetSpeed) / CONFIG.targetMoveSpeed);
            showDiff(elDiffClick, (currStats.click - prevStats.click) / CONFIG.baseClick);
        } else {
            [elDiffDecay, elDiffEnemy, elDiffTarget, elDiffClick].forEach(el => { el.innerText = ""; el.style.opacity = 0; });
        }
    }

    function showDiff(element, val) {
        if(val <= 0) return;
        element.innerText = `+${val.toFixed(2)}`;
        element.style.transition = 'none'; 
        element.style.opacity = 1;
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                element.style.transition = 'opacity 1.5s ease-in';
                element.style.opacity = 0;
            });
        });
    }

    function gameLoop(timestamp) {
        if (!state.isPlaying) return;
        const dt = (timestamp - state.lastTime) / 1000;
        state.lastTime = timestamp;
        const stats = getStageStats(state.stage);

        if (state.gauge > 0) { state.gauge -= stats.decay; if (state.gauge < 0) state.gauge = 0; }

        if (Math.abs(state.targetPos - state.targetDest) < 2) { state.targetDest = Math.random() * 80 + 15; }
        const direction = state.targetDest > state.targetPos ? 1 : -1;
        state.targetPos += direction * stats.targetSpeed;

        let diff = Math.abs(state.gauge - state.targetPos);
        let rawEfficiency = 0, rawJudgment = "MISS";

        if (state.gauge < CONFIG.minActiveGauge) { rawJudgment = "LOW"; }
        else {
            if (diff < CONFIG.tolerance) { rawJudgment = "PERFECT"; rawEfficiency = 1; }
            else if (diff < 35) { rawJudgment = "GOOD"; rawEfficiency = 1 - ((diff - CONFIG.tolerance) / (35 - CONFIG.tolerance)); }
            else { rawJudgment = "MISS"; rawEfficiency = 0; }
        }

        let finalJudgment = rawJudgment;
        if (rawJudgment === "PERFECT") { state.graceTimer = CONFIG.gracePeriod; }
        else if (state.graceTimer > 0) { state.graceTimer -= dt; finalJudgment = "PERFECT"; rawEfficiency = 1; }

        let displayText = "", textGlow = "", moveAmount = 0, bgClass = "bg-normal", effectAlpha = 0.2;

        if (finalJudgment === "LOW") {
            displayText = "LOW"; textGlow = "0 0 10px #888"; 
            moveAmount = stats.enemySpeed; state.perfectDuration = 0; bgClass = "bg-miss";
        } else if (finalJudgment === "PERFECT") {
            state.perfectDuration += dt;
            let currentPullSpeed = CONFIG.perfectPullSpeed;
            if (state.perfectDuration >= CONFIG.sustainThreshold) {
                const extraTime = state.perfectDuration - CONFIG.sustainThreshold;
                const extraSteps = Math.floor(extraTime / CONFIG.sustainInterval);
                const multiplier = CONFIG.sustainBaseMult + (extraSteps * CONFIG.sustainIncMult);
                currentPullSpeed *= multiplier;
                displayText = `MAX x${multiplier.toFixed(2)}`;
                textGlow = "0 0 15px #00e5ff, 0 0 30px #00e5ff"; bgClass = "bg-bonus"; effectAlpha = 0.9;
            } else {
                displayText = "PERFECT"; textGlow = "0 0 10px #4caf50, 0 0 20px #4caf50"; 
                bgClass = "bg-perfect"; effectAlpha = 0.7;
            }
            moveAmount = -currentPullSpeed;
        } else if (finalJudgment === "GOOD") {
            state.perfectDuration = 0; displayText = "GOOD"; textGlow = "0 0 10px #ffeb3b, 0 0 20px #ffeb3b"; 
            moveAmount = stats.enemySpeed - (CONFIG.pullPower * rawEfficiency);
            bgClass = "bg-good"; effectAlpha = 0.2 + (rawEfficiency * 0.5);
        } else {
            state.perfectDuration = 0; displayText = "MISS"; textGlow = "0 0 10px #f44336, 0 0 20px #f44336"; 
            moveAmount = stats.enemySpeed; bgClass = "bg-miss"; effectAlpha = 0.2;
        }

        elAccuracyText.innerText = displayText; elAccuracyText.style.textShadow = textGlow;
        elBgOverlay.className = bgClass; elEffectC.style.opacity = effectAlpha;
        state.posA += moveAmount;

        if (state.posA <= 0) winStage();
        else if (state.posA >= 100) gameOver();
        else { render(); state.animationId = requestAnimationFrame(gameLoop); }
    }

    function render() {
        let visualPos = state.posA < 0 ? 0 : (state.posA > 100 ? 100 : state.posA);
        elPlayerA.style.left = `${visualPos}%`;
        elGaugeFill.style.width = `${state.gauge}%`;
        elTargetLine.style.left = `${state.targetPos}%`;
    }

    function increaseGauge() {
        if (!state.isPlaying) return;
        state.gauge += getStageStats(state.stage).click;
        if (state.gauge > 100) state.gauge = 100;
        elGaugeFill.style.filter = "brightness(1.5)";
        setTimeout(() => elGaugeFill.style.filter = "brightness(1)", 50);
    }

    function startGame() {
        state.isPlaying = true; state.posA = 50; state.gauge = 0; state.stage = 1;
        state.targetPos = 50; state.targetDest = 60; state.lastTime = performance.now();
        state.perfectDuration = 0; state.graceTimer = 0;
        
        elStageInfo.innerText = "STAGE 1"; elFloatingContainer.innerHTML = '';
        
        // 텍스트 및 스타일 리셋
        elAccuracyText.innerText = "START"; 
        elAccuracyText.style.fontSize = "24px"; // 폰트 크기 원복
        elAccuracyText.style.textShadow = "none";
        
        elFlashLayer.className = ""; elBgOverlay.className = "bg-normal";
        updateStatsUI(null);
        state.animationId = requestAnimationFrame(gameLoop);
    }

    function showFloatingText(currStats) {
        elFloatingContainer.innerHTML = ''; 
        const div = document.createElement('div');
        div.className = 'hit-text';
        div.innerText = `속도 ${(currStats.enemySpeed / CONFIG.baseEnemySpeed).toFixed(2)}x`;
        elFloatingContainer.appendChild(div);
    }

    function winStage() {
        cancelAnimationFrame(state.animationId);
        const prevStats = getStageStats(state.stage); state.stage++;
        showFloatingText(getStageStats(state.stage)); updateStatsUI(prevStats);
        elStageInfo.innerText = `STAGE ${state.stage}`;
        elFlashLayer.className = ""; void elFlashLayer.offsetWidth; elFlashLayer.classList.add("flash-white");
        elBgOverlay.className = "bg-normal";
        state.posA = 50; state.gauge = 0; state.perfectDuration = 0; state.lastTime = performance.now();
        render();
        state.animationId = requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        state.isPlaying = false; state.isRestartLocked = true; cancelAnimationFrame(state.animationId);
        
        // 상단 부유 텍스트 제거
        elFloatingContainer.innerHTML = ''; 

        // 게임오버 타이틀
        const titleDiv = document.createElement('div');
        titleDiv.className = 'game-over-title'; titleDiv.innerText = 'GAME OVER';
        elFloatingContainer.appendChild(titleDiv);

        const savedMax = localStorage.getItem('ptw_max_stage') || 1;
        const maxStage = Math.max(state.stage, parseInt(savedMax));
        localStorage.setItem('ptw_max_stage', maxStage);

        // [수정] 기록 텍스트를 판정 텍스트 칸에 주입
        elAccuracyText.innerHTML = `기록: STAGE ${state.stage} &nbsp;|&nbsp; 최고: STAGE ${maxStage}`;
        elAccuracyText.style.fontSize = "16px"; // 공간에 맞게 폰트 조절
        elAccuracyText.style.textShadow = "none";
        elAccuracyText.style.color = "#fff";

        elFlashLayer.className = ""; void elFlashLayer.offsetWidth; elFlashLayer.classList.add("flash-red");
        btnAction.innerText = "WAIT..."; btnAction.classList.add("locked");
        setTimeout(() => { state.isRestartLocked = false; btnAction.innerText = "RESTART"; btnAction.classList.remove("locked"); }, 2000);
    }

    function handleInput() {
        if (state.isModalOpen) return;
        if (!state.isPlaying) {
            if (state.isRestartLocked) return;
            startGame(); btnAction.innerText = "SPACE!";
        } else { increaseGauge(); }
    }

    btnAction.addEventListener('mousedown', (e) => { e.stopPropagation(); handleInput(); });
    btnAction.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); handleInput(); });
    window.addEventListener('keydown', (e) => { if (e.code === 'Space') handleInput(); });

    updateStatsUI(null); render();
</script>
</body>
</html>
